**检测点 3.1：**

1. 在 Debug 中，用 `d 0:0 1f` 查看内存，结果如下。

    ```
    0000:0000 70 80 F0 30 EF 60 30 E2-00 80 80 12 66 20 22 60
    0000:0010 62 26 E6 D6 CC 2E 3C 3B-AB BA 00 00 26 06 66 88
    ```

    下面的程序执行前，AX = 0，BX = 0，写出每条汇编指令执行完后相关寄存器中的值。

    ```assembly
    mov ax, 1
    mov ds, ax
    mov ax, [0000]      ; AX = 2662
    mob bx, [0001]      ; BX = E626
    mov ax, bx          ; AX = E626
    mov ax, [0000]      ; AX = 2662
    mov bx, [0002]      ; BX = D6E6
    add ax, bx          ; AX = FD48
    add ax, [0004]      ; AX = 2C14
    mov ax, 0           ; AX = 0000
    mov al, [0002]      ; AX = 00E6
    mov bx, 0           ; BX = 0000
    mov bl, [000C]      ; BX = 0026
    add al, bl          ; AX = 000C
    ```

2. 内存中的情况如图 3.6 所示。

   各寄存器的初始值：CS = 2000H，IP = 0，DS = 1000H，AX = 0，BX = 0；

   1. 写出 CPU 执行的指令序列（用汇编指令写出）。
   2. 写出 CPU 执行每条指令后，CS、IP 和相关寄存器中的数值。
   3. 再次体会：数据和程序有区别吗？如何确定内存中的信息哪些是数据，哪些是程序？

    | Instruction      | CS     | IP     | DS     | AX     | BX     |
    | ---------------- | ------ | ------ | ------ | ------ | ------ |
    | `mov ax, 6622`   | `2000` | `0003` | `1000` | `6622` | `0000` |
    | `jmp 0ff0:0100`  | `0FF0` | `0100` | `1000` | `6622` | `0000` |
    | `mov ax, 2000`   | `0FF0` | `0103` | `1000` | `2000` | `0000` |
    | `mov ds, ax`     | `0FF0` | `0105` | `2000` | `2000` | `0000` |
    | `mov ax, [0008]` | `0FF0` | `0108` | `2000` | `C389` | `0000` |
    | `mov ax, [0002]` | `0FF0` | `010B` | `2000` | `EA66` | `0000` |
